{"version":3,"sources":["views/overview/Analysis/index.jsx"],"names":["Analysis","props","useState","name","number","counter","setCounter","setNumber","setSourceData","useEffect","data","i","theta","r","Math","sin","PI","push","echarts","document","getElementById","setOption","title","text","legend","polar","tooltip","trigger","axisPointer","type","angleAxis","startAngle","radiusAxis","series","coordinateSystem","className","gutter","span","id","style","width","height","onClick","setTimeout"],"mappings":"yMA8FeA,UAnFE,SAACC,GAChB,MAA+BC,mBAAS,CAAEC,KAAK,qBAAMC,OAAO,IAA5D,mBAAQC,EAAR,KAAgBC,EAAhB,KACA,EAA8BJ,mBAAS,GAAvC,mBAAQE,EAAR,KAAgBG,EAAhB,KACA,EAAsCL,mBAAS,IAA/C,mBAAoBM,GAApB,WAmDA,OA5CAC,qBAAU,WAER,IADA,IAAMC,EAAO,GACJC,EAAI,EAAGA,GAAK,IAAKA,IAAK,CAC7B,IAAMC,EAAQD,EAAI,IAAM,IAClBE,EAAI,GAAK,EAAIC,KAAKC,IAAIH,EAAQ,IAAME,KAAKE,KAC/CN,EAAKO,KAAK,CAAEJ,EAAGD,IAEjBJ,EAAcE,GAOEQ,IAAaC,SAASC,eAAe,SAE7CC,UAAU,CAChBC,MAAO,CACLC,KAAM,8CAERC,OAAQ,CACNd,KAAM,CAAE,SAEVe,MAAO,GACPC,QAAS,CACPC,QAAS,OACTC,YAAa,CACXC,KAAM,UAGVC,UAAW,CACTD,KAAM,QACNE,WAAY,GAEdC,WAAY,GAEZC,OAAQ,CAAE,CACRC,iBAAkB,QAClB/B,KAAM,OACN0B,KAAM,OACNnB,KAAMA,QAGT,IAED,sBAAKyB,UAAU,iBAAf,UACE,eAAC,IAAD,CAAKC,OAAS,GAAd,UACE,cAAC,IAAD,CAAKC,KAAO,EAAZ,SACE,cAAC,IAAD,UACE,qBAAKC,GAAK,OAAOC,MAAU,CAAGC,MAAO,IAAKC,OAAQ,KAAlD,mBAGJ,cAAC,IAAD,CAAKJ,KAAO,EAAZ,2BAGA,cAAC,IAAD,CAAKA,KAAO,EAAZ,2BAGA,cAAC,IAAD,CAAKA,KAAO,EAAZ,8BAIF,4BAAIjC,IACJ,8BAAIC,EAAQF,KAAZ,IAAmBE,EAAQD,UAC3B,wBAAQsC,QAAU,kBAAMnC,EAAUH,EAAS,IAA3C,sBACA,wBAAQsC,QAvEZ,WACEC,YAAW,WACTpC,EAAUH,EAAS,KAElB,IAmED,kBAEA,wBAAQsC,QAAU,kBAAIpC,EAAW,2BAAKD,GAAN,IAAcD,OAAOC,EAAQD,OAAO,MAApE,eACA,wBAAQsC,QAAU,kBAAIpC,EAAWD,IAAjC","file":"static/js/14.018cc61b.chunk.js","sourcesContent":["import React, { useState, useEffect } from 'react'\nimport { Row, Col, Card } from 'antd';\n// 引入ECharts主模块 \nimport * as echarts from 'echarts';\n// 引入折线图需要的模块 \n// import \"echarts/lib/chart/line\";\n// import \"echarts/lib/component/title\";\n// import \"echarts/lib/component/tooltip\";\n// import \"echarts/lib/component/legend\";\n// import 'echarts/lib/component/polar';\n\nconst Analysis = (props) => {\n  const [ counter,setCounter ] = useState({ name:'计数器',number:0 });\n  const [ number, setNumber ] = useState(0)\n  const [ sourceData, setSourceData ] = useState([])\n  function lazy () {\n    setTimeout(() => {\n      setNumber(number + 1)\n      // setNumber(number => number + 1)\n    }, 0)\n  }\n  useEffect(() => {\n    const data = [];\n    for (let i = 0; i <= 100; i++) {//根据公式,生成绘制在图上的坐标数据源数组\n      const theta = i / 100 * 360;\n      const r = 5 * (1 + Math.sin(theta / 180 * Math.PI));\n      data.push([ r, theta ]);\n    }\n    setSourceData(data)\n    // this.setState(() => {\n    //     return {\n    //         sourceData: data//更新react组件的state数据\n    //     };\n    // });\n    // 初始化Echarts实例，将其挂载到id为main的dom元素上展示  \n    const myChart = echarts.init(document.getElementById('main'));\n    // 绘制Echarts实例所需要的数据\n    myChart.setOption({\n      title: {\n        text: '极坐标双数值轴'\n      },\n      legend: {\n        data: [ 'line' ]\n      },\n      polar: {},\n      tooltip: {\n        trigger: 'axis',\n        axisPointer: {\n          type: 'cross'\n        }\n      },\n      angleAxis: {\n        type: 'value',\n        startAngle: 0\n      },\n      radiusAxis: {\n      },\n      series: [ {\n        coordinateSystem: 'polar',//极坐标图\n        name: 'line',\n        type: 'line',\n        data: data //根据已生成的坐标数组来绘制爱心图形\n      } ]\n    });\n  }, [])\n  return (\n    <div className=\"page-container\">\n      <Row gutter={ 24 }>\n        <Col span={ 6 }>\n          <Card>\n            <div id = \"main\" style = { {  width: 300, height: 300 } }> </div>\n          </Card>\n        </Col>\n        <Col span={ 6 }>\n          2 col-order-3\n        </Col>\n        <Col span={ 6 }>\n          3 col-order-2\n        </Col>\n        <Col span={ 6 }>\n          4 col-order-1\n        </Col>\n      </Row>\n      <p>{number}</p>\n      <p>{counter.name}:{counter.number}</p>\n      <button onClick={ () => setNumber(number + 1) }> 加1</button>\n      <button onClick={ lazy }>lazy</button>\n\n      <button onClick={ ()=>setCounter({ ...counter,number:counter.number+1 }) }>+</button>\n      <button onClick={ ()=>setCounter(counter) }>++</button>\n    </div>\n  )\n}\n\nexport default Analysis\n\n// function SubCounter({onClick,data}){\n//   console.log('SubCounter render');\n//   return (\n//     <button onClick={onClick}>{data.number}</button>\n//   )\n// }\n// SubCounter = memo(SubCounter);\n\n// export default function Counter6(){\n//   console.log('Counter render');\n//   const [name,setName]= useState('计数器');\n//   const [number,setNumber] = useState(0);\n//   const data ={number};\n//   const addClick = ()=>{\n//     setNumber(number+1);\n//   };\n//   return (\n//     <>\n//       <input type=\"text\" value={name} onChange={(e)=>setName(e.target.value)}/>\n//       <SubCounter data={data} onClick={addClick}/>\n//     </>\n//   )\n// }\n\n// let oldData,oldAddClick;\n// export  default  function Counter2(){\n//     console.log('Counter render');\n//     const [name,setName]= useState('计数器');\n//     const [number,setNumber] = useState(0);\n//     // 父组件更新时，这里的变量和函数每次都会重新创建，那么子组件接受到的属性每次都会认为是新的\n//     // 所以子组件也会随之更新，这时候可以用到 useMemo\n//     // 有没有后面的依赖项数组很重要，否则还是会重新渲染\n//     // 如果后面的依赖项数组没有值的话，即使父组件的 number 值改变了，子组件也不会去更新\n//     //const data = useMemo(()=>({number}),[]);\n//     const data = useMemo(()=>({number}),[number]);\n//     console.log('data===oldData ',data===oldData);\n//     oldData = data;\n    \n//     // 有没有后面的依赖项数组很重要，否则还是会重新渲染\n//     const addClick = useCallback(()=>{\n//         setNumber(number+1);\n//     },[number]);\n//     console.log('addClick===oldAddClick ',addClick===oldAddClick);\n//     oldAddClick=addClick;\n//     return (\n//       <>\n//         <input type=\"text\" value={name} onChange={(e)=>setName(e.target.value)}/>\n//         <SubCounter data={data} onClick={addClick}/>\n//       </>\n//     )\n// }\n"],"sourceRoot":""}